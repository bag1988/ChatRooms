@page "/"
@page "/Messages/{CurrentUser}/{SelectUser}"
@using ChatRooms.Components.Layout
@rendermode InteractiveServer
@inject IJSRuntime JS
@implements IAsyncDisposable
@inject HttpClient Http
@attribute [StreamRendering]
<PageTitle>@SelectUser</PageTitle>


<button @onclick="()=>StartWebCam()">Start webcam stream</button>
<button @onclick="()=>StartWebCam(false)">Start display stream</button>
<button @onclick="StopStream">Stop stream</button>

<div class="d-flex">
    @if (stream != null)
    {
        <div>
            <h2>Local</h2>
            <video id="localVideo" class="d-none w-50" controls autoplay type="video/webm"></video>
        </div>
    }
    <div>
        <h2>Remote</h2>
        <video id="remoteVideo" class="w-50" controls type="video/webm"></video>
    </div>
    @* @if (!string.IsNullOrEmpty(RemoteVideo))
    {
    <div>
    <h2>Remote</h2>
    <video id="remoteVideo" preload="auto" autoplay src="@RemoteVideo"></video>
    </div>
    } *@
</div>




<div class="form-group">
    <label>
        Message:
        <input @bind="messageInput" size="50" />
    </label>
</div>
<button @onclick="Send" disabled="@(!IsConnected)">Send</button>

@foreach (var item in messages)
{
    <div>@item</div>
}

@code {
    [Parameter]
    public string CurrentUser { get; set; } = string.Empty;

    [Parameter]
    public string? SelectUser { get; set; }

    private HubConnection? hubConnection;

    List<string> messages = new();

    private string? messageInput;

    DotNetObjectReference<Messages>? _this;

    string? RemoteVideo = null;

    //ElementReference? remotePlayer;

    protected override async Task OnInitializedAsync()
    {
        _this = DotNetObjectReference.Create(this);
        if (!string.IsNullOrEmpty(CurrentUser))
        {
            await ReConnectHub();
        }
    }

    async Task ReConnectHub()
    {
        hubConnection = new HubConnectionBuilder()
           .WithUrl(Navigation.ToAbsoluteUri("/chathub"), options =>
           {
               options.Headers.Add("user", CurrentUser);
           }).Build();

        hubConnection.On<string, string>("ReceiveMessage", (user, message) =>
        {
            var encodedMsg = $"{user}: {message}";
            messages.Add(encodedMsg);
            InvokeAsync(StateHasChanged);
        });

        hubConnection.On<string, string>("SetRemoteVideo", (user, urlFile) =>
        {
            var encodedMsg = $"{user}: {urlFile}";
            RemoteVideo = $"api/ReadFile/GetVideoStream/{urlFile}";
            //RemoteVideo = $"blob:http://localhost:5187/tmpvideo/{urlFile}.webm";
            InvokeAsync(StateHasChanged);
        });

        await hubConnection.StartAsync();

        await GetAllMessages();
    }
    async Task GetAllMessages()
    {
        if (hubConnection != null)
        {
            messages = await hubConnection.InvokeAsync<List<string>?>("GetAllMessagesForUser", SelectUser) ?? new();
        }
    }

    FileStream? stream = null;
    async Task StartWebCam(bool isWebCam = true)
    {

        var fileName = Guid.NewGuid().ToString();

        var urlFile = $"tmpvideo/{fileName}.webm";

        if (!Directory.Exists("wwwroot/tmpvideo"))
        {
            Directory.CreateDirectory("wwwroot/tmpvideo");
        }

        stream = new FileStream($"wwwroot/{urlFile}", FileMode.Create, FileAccess.Write);
        var b = await JS.InvokeAsync<bool>("startStream", _this, isWebCam);
        if (!b)
        {
            await StopStreamToFile();
        }
        else if (hubConnection != null && IsConnected)
        {
            await hubConnection.SendAsync("SendVideoForUser", CurrentUser, SelectUser, fileName);
        }
        //await Task.Delay(1000);
        //RemoteVideo = $"api/ReadFile/GetVideoStream/{fileName}";
        // var imageStream = GetFileStream($"wwwroot/tmpvideo/{fileName}.webm");
        // var dotnetImageStream = new DotNetStreamReference(imageStream, true);
        //await JS.InvokeVoidAsync("setStream", dotnetImageStream);
        await JS.InvokeVoidAsync("initRemotePlayer");

        // StateHasChanged();
    }
    private Stream GetFileStream(string url)
    {
        var readFile = new FileStream(url, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
        return readFile;
    }


    async Task StopStream()
    {
        await JS.InvokeVoidAsync("stopStream");
    }

    [JSInvokable(nameof(StreamToFile))]
    public async Task StreamToFile(byte[]? btoa, uint? timestamp, string? chunk_type)
    {
        //Console.WriteLine("Получено {0} байт", btoa?.Length);
        await JS.InvokeVoidAsync("setStream", btoa, timestamp, chunk_type);

        // if (stream != null)
        // {
        //     await stream.WriteAsync(btoa);
        // }
    }

    [JSInvokable(nameof(StopStreamToFile))]
    public async Task StopStreamToFile()
    {
        Console.WriteLine("Ожидание остановка записи");
        await Task.Delay(1000);
        if (stream != null)
        {
            stream.Close();
            stream.Dispose();
            stream = null;
        }
        Console.WriteLine("Остановка записи");


        await JS.InvokeVoidAsync("removeWorker");

    }

    private async Task Send()
    {
        if (!string.IsNullOrEmpty(messageInput))
        {
            messages.Add(messageInput);
            if (hubConnection is not null)
            {
                await hubConnection.SendAsync("SendMessageForUser", CurrentUser, SelectUser, messageInput);
            }
            messageInput = null;
        }
    }

    public bool IsConnected => hubConnection?.State == HubConnectionState.Connected;

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
    }
}
